using System;

namespace Test.src.Algorithms.Sorting
{
    /// <summary>
    /// Реализует алгоритм сортировки пузырьком для массивов.
    /// 
    /// <para>
    /// Сортировка пузырьком - это простой алгоритм сортировки на основе сравнения.
    /// Он многократно проходит по списку, сравнивает соседние элементы и меняет их местами, если они находятся в неправильном порядке.
    /// Проход по списку повторяется до тех пор, пока список не будет отсортирован.
    /// </para>
    /// 
    /// <para>
    /// Временная сложность: O(n²) в худшем и среднем случаях, O(n) в лучшем случае (уже отсортированный массив).
    /// Пространственная сложность: O(1) - сортировка на месте, использует только постоянное количество дополнительной памяти.
    /// </para>
    /// 
    /// <para>
    /// Применение: Образовательные цели, маленькие наборы данных, когда простота важнее эффективности.
    /// Не рекомендуется для больших наборов данных из-за временной сложности O(n²).
    /// </para>
    /// </summary>
    public class BubbleSort
    {
        /// <summary>
        /// Сортирует массив целых чисел по возрастанию используя алгоритм сортировки пузырьком.
        /// 
        /// Шаги алгоритма:
        /// 1. Итерация по массиву от первого до предпоследнего элемента
        /// 2. Для каждого элемента сравниваем его со следующим элементом
        /// 3. Если текущий элемент больше следующего, меняем их местами
        /// 4. После каждого прохода наибольший неотсортированный элемент "всплывает" в конец
        /// 5. Повторяем до тех пор, пока не потребуется обменов (массив отсортирован)
        /// </summary>
        /// <param name="array">Массив для сортировки (будет изменён на месте).</param>
        /// <returns>Отсортированный массив (тот же объект, что и на входе).</returns>
        /// <exception cref="ArgumentNullException">Выбрасывается когда массив равен null.</exception>
        public static int[] Sort(int[] array)
        {
            // Проверяем входные данные для предотвращения исключений null reference
            if (array == null)
            {
                throw new ArgumentNullException(nameof(array), "Массив не может быть null.");
            }

            // Если массив содержит 0 или 1 элемент, он уже отсортирован - работа не нужна
            if (array.Length <= 1)
            {
                return array;
            }

            // Внешний цикл: контролирует количество проходов по массиву
            // После каждого прохода мы знаем, что последний элемент находится в правильной позиции
            // Поэтому можем уменьшить диапазон внутреннего цикла на 1 с каждой итерацией
            for (int i = 0; i < array.Length - 1; i++)
            {
                // Флаг для оптимизации: если не было обменов, массив уже отсортирован
                bool swapped = false;

                // Внутренний цикл: сравниваем соседние элементы
                // Вычитаем 'i', потому что после каждого прохода последние 'i' элементов уже отсортированы
                // Это уменьшает ненужные сравнения
                for (int j = 0; j < array.Length - 1 - i; j++)
                {
                    // Сравниваем текущий элемент со следующим
                    // Если текущий больше, они в неправильном порядке - нужно поменять местами
                    if (array[j] > array[j + 1])
                    {
                        // Меняем элементы местами: временно сохраняем одно значение, затем меняем
                        // Это основная операция сортировки пузырьком
                        int temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;

                        // Отмечаем, что произошёл обмен - массив ещё не был отсортирован
                        swapped = true;
                    }
                }

                // Оптимизация: если в этом проходе не было обменов, массив отсортирован
                // Можем выйти досрочно вместо продолжения ненужных проходов
                // Это делает сложность в лучшем случае O(n) вместо O(n²)
                if (!swapped)
                {
                    break;
                }
            }

            // Возвращаем отсортированный массив (тот же объект - отсортирован на месте)
            return array;
        }

        /// <summary>
        /// Сортирует массив целых чисел по убыванию используя сортировку пузырьком.
        /// Тот же алгоритм, но сравнение обращено (меньше вместо больше).
        /// </summary>
        /// <param name="array">Массив для сортировки по убыванию.</param>
        /// <returns>Отсортированный массив по убыванию.</returns>
        /// <exception cref="ArgumentNullException">Выбрасывается когда массив равен null.</exception>
        public static int[] SortDescending(int[] array)
        {
            if (array == null)
            {
                throw new ArgumentNullException(nameof(array), "Массив не может быть null.");
            }

            if (array.Length <= 1)
            {
                return array;
            }

            for (int i = 0; i < array.Length - 1; i++)
            {
                bool swapped = false;

                for (int j = 0; j < array.Length - 1 - i; j++)
                {
                    // Обращённое сравнение: меняем если текущий МЕНЬШЕ следующего (для убывающего порядка)
                    if (array[j] < array[j + 1])
                    {
                        int temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                        swapped = true;
                    }
                }

                if (!swapped)
                {
                    break;
                }
            }

            return array;
        }

        /// <summary>
        /// Демонстрирует алгоритм сортировки пузырьком с примерами использования и вывода.
        /// </summary>
        public static void Demonstrate()
        {
            Console.WriteLine("=== Демонстрация сортировки пузырьком ===\n");

            // Пример 1: Неотсортированный массив
            int[] numbers = { 64, 34, 25, 12, 22, 11, 90 };
            Console.WriteLine("Исходный массив: [{0}]", string.Join(", ", numbers));

            int[] sorted = Sort((int[])numbers.Clone()); // Клонируем чтобы сохранить оригинал
            Console.WriteLine("Отсортированный массив:   [{0}]", string.Join(", ", sorted));
            Console.WriteLine();

            // Пример 2: Уже отсортированный массив (лучший случай - O(n))
            int[] alreadySorted = { 1, 2, 3, 4, 5 };
            Console.WriteLine("Уже отсортированный: [{0}]", string.Join(", ", alreadySorted));
            int[] sorted2 = Sort((int[])alreadySorted.Clone());
            Console.WriteLine("Результат:         [{0}]", string.Join(", ", sorted2));
            Console.WriteLine();

            // Пример 3: Убывающий порядок
            int[] descending = { 90, 64, 34, 25, 22, 12, 11 };
            Console.WriteLine("Исходный:       [{0}]", string.Join(", ", descending));
            int[] sortedDesc = SortDescending((int[])descending.Clone());
            Console.WriteLine("По убыванию:     [{0}]", string.Join(", ", sortedDesc));
        }
    }
}
